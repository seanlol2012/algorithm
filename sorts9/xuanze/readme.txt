选择排序：

基本思想：从第一个位置开始依次选择该位置的元素，第i次扫描就可以选出第i小的元素。
特点：平均时间复杂度O(n^2)，最坏时间复杂度O(n^2)，额外空间O(1)，不稳定排序，n较小时较好。


冒泡排序：

基本思想：每一轮都通过相邻元素两两比较，通过交换将较小的元素往前移动。
特点：平均时间复杂度O(n^2)，最坏时间复杂度O(n^2)，额外空间O(1)，稳定排序，n较小时较好。


插入排序：

基本思想：假定一个已排好序的序列和一个元素，只需要将该元素从序列末尾向前比较，找到第一个小于它的序列元素，排在其之后即可。
特点：平均时间复杂度O(n^2)，最坏时间复杂度O(n^2)，额外空间O(1)，稳定排序（比较元素和序列时，找到序列中相等元素的话，排在其之后），序列大部分已排好序时（时间复杂度可提升至O(n)）较好。


希尔排序：

基本思想：插入排序的升级版，将数据分为不同的组，先对每一组进行排序，然后对所有元素进行一次排序（即最后步长必须为1），步长是递减的。
特点：平均时间复杂度O(n*logn)，最坏时间复杂度O(n^s)(1<s<2)，额外空间O(1)，不稳定排序。


归并排序：

基本思想：分治的思想，就是用递归先将序列分解成只剩一个元素的子序列，然后逐渐向上进行合并，每次合并过程就是将两个内部已排序的子序列进行合并排序，只需要O(n)时间。
特点：平均时间复杂度O(n*logn)，最坏时间复杂度O(n*logn)，额外空间O(n)（另外需要一个数组），稳定排序，当n较大时较好（当也不能太大，用了递归就要考虑栈溢出）。


快速排序：

基本思想：快排是目前使用最多的排序算法，每次都是先选择一个位置的元素（可以为序列的最左或最右位置）作为中间值，将比其小的元素放在其左边，比其大的元素放在右边，然后递归对其左边和右边的子序列进行相同操作，直到子序列为单个元素。
特点：平均时间复杂度O(n*logn)，最坏时间复杂度O(n^2)（序列基本有序时，退化为冒泡排序），额外空间O(logn)，不稳定排序。当n较大时较好（当也不能太大，用了递归就要考虑栈溢出）。


堆排序

基本思想：利用最大堆的性质――父节点拥有最大值，所以不断的将堆的根节点与最后节点交换，减小堆长度，然后再恢复堆性质，堆排序主要就是建立最大堆和不断恢复堆性质两个过程。堆排序不需要用到递归，所以适合海量数据处理，同时堆还可以用于优先级队列。
特点：平均时间复杂度O(n*logn)，最坏时间复杂度O(n*logn)，额外空间O(1)，不稳定排序，当n较大时较好（海量数据）。


计数排序

基本思想：假定输入是有一个小范围内的整数构成的（比如年龄等），利用额外的数组去记录元素应该排列的位置。
特点：在一定限制下时间复杂度为O(n)，额外空间O(n)（需要两个数组），稳定排序。


基数排序

基本思想：只适用于整数排序，确定序列中元素的最大位数d，只要进行d次循环，从低位开始根据相应位置的数进行排序。
特点：在一定限制下时间复杂度为O(n)，额外空间O(n)（需要两个数组），稳定排序。